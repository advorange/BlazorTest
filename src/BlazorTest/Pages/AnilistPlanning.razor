@page "/anilistplanning"
@inject HttpClient Http

<PageTitle>Planning List Sorter</PageTitle>

<h1>Planning List Sorter</h1>

<input type="text" @bind-value="@username" />
<button class="btn btn-primary btn-sm" @onclick="@GetEntries">
	Get Entries
</button>
<button class="btn btn-primary btn-sm float-end" @onclick="@search.ToggleModal">
	Search
</button>

@if (search.IsModalActive)
{
	<div class="modal d-block" id="searchModal" role="dialog" @onclick="@search.ToggleModal">
		@* onclick:stopPropagation so the @onclick to close the menu doesn't trigger *@
		@* when clicking any of the elements inside the modal *@
		<div class="modal-dialog" role="document" @onclick:stopPropagation="true">
			<div class="modal-content">
				<div>
					<div class="w-25 float-start" style="background:red">
						<h5>first</h5>
					</div>
					<div class="w-25 float-start" style="background:green">
						<h5>second</h5>
					</div>
					<div class="w-25 float-start" style="background:blue">
						<h5>third</h5>
					</div>
				</div>
				<div class="m-2 bg-primary">
					<h5 class="modal-title" for="genres">Genres</h5>
					<select class="w-25" name="genres" id="genres"
							@onchange="@GenreSelected">
						<option class="d-none" selected disabled hidden value="">
							Select Genre
						</option>
						@foreach (var genre in search.AvailableGenres)
						{
							<option value="@genre">@genre</option>
						}
					</select>
				</div>
				<div class="m-2 bg-secondary">
					<h5 class="modal-title" for="tags">Tags</h5>
					<select class="w-25" name="tags" id="tags"
							@onchange="@TagSelected">
						<option class="d-none" selected disabled hidden value="">
							Select Tag
						</option>
						@foreach (var tag in search.AvailableTags)
						{
							<option value="@tag">@tag</option>
						}
					</select>
				</div>
			</div>
		</div>
	</div>
}

@if (entries == null)
{
	<p><em>Please enter a username to get entries for...</em></p>
}
else if (!entries.Any())
{
	<p><em>No entries were found for @username.</em></p>
}
else
{
	<table class="table table-striped table-bordered">
		<thead>
			<tr>
				<th>
					<span class="sort-link" onclick="@(() => SortEntries(e => e.Id))">
						Id
					</span>
				</th>
				<th>
					<span class="sort-link" onclick="@(() => SortEntries(e => e.Title.UserPreferred))">
						Name
					</span>
				</th>
				<th>
					<span class="sort-link" onclick="@(() => SortEntries(e => e.Format))">
						Format
					</span>
				</th>
				<th>
					<span class="sort-link" onclick="@(() => SortEntries(e => e.GetHighestEpisode()))">
						Episode Count
					</span>
				</th>
				<th>
					<span class="sort-link" onclick="@(() => SortEntries(e => e.GetTotalDuration()))">
						Duration
					</span>
				</th>
				<th>
					<span class="sort-link" onclick="@(() => SortEntries(e => e.AverageScore))">
						Average Score
					</span>
				</th>
				<th>
					<span class="sort-link" onclick="@(() => SortEntries(e => e.Popularity))">
						Popularity
					</span>
				</th>
				<th>
					<span class="sort-link" onclick="@(() => SortEntries(e => e.StartDate!.Year))">
						Start Year
					</span>
				</th>
				<th>Genres</th>
				<th>Tags</th>
			</tr>
		</thead>
		<tbody>
			@foreach (var entry in entries)
			{
				if (!entry.IsEntryVisible)
				{
					continue;
				}
				<tr class="text-nowrap">
					<td>
						<a href="@entry.GetUrl()" target="_blank">@entry.Id</a>
					</td>
					<td class="text-wrap">@entry.Title.UserPreferred</td>
					<td>@entry.DisplayFormat()</td>
					<td>@entry.DisplayEpisodeCount()</td>
					<td>@entry.DisplayDuration()</td>
					<td>@entry.DisplayScore()</td>
					<td>@entry.Popularity</td>
					<td>@entry.DisplayYear()</td>
					@* button added before the text otherwise the button gets positioned *@
					@* to be at the bottom right of the text *@
					@* float-end aligns it to the right correctly, but makes the vertical *@
					@* alignment a bit off centered (it's not a huge issue) *@
					<td class="text-pre">
						@if (entry.Genres.Count > 1)
						{
							<button class="btn btn-secondary btn-xs float-end ms-4"
									@onclick="@(() => entry.ToggleGenresExpanded())">
								@entry.Genres.DisplayExpanderButton(entry.IsGenresExpanded)
							</button>
						}
						@entry.DisplayGenres(entry.IsGenresExpanded)
					</td>
					<td class="text-pre">
						@if (entry.Tags.Count > 1)
						{
							<button class="btn btn-secondary btn-xs float-end ms-4"
									@onclick="@(() => entry.ToggleTagsExpanded())">
								@entry.Tags.DisplayExpanderButton(entry.IsTagsExpanded)
							</button>
						}
						@entry.DisplayTags(entry.IsTagsExpanded)
					</td>
				</tr>
			}
		</tbody>
	</table>
}

@code {
	private Search search = new();
	private string? username;
	private List<Media>? entries;
	private LastSortedBy lastSortedBy;

	private async Task GetEntries()
	{
#if false
	var response = await AnilistResponse.GetAnilistResponseAsync(Http, username!).ConfigureAwait(false);
#else
		var response = (await Http.GetFromJsonAsync<AnilistResponse>(
			requestUri: "sample-data/anilistresponse3.json",
			options: AnilistResponse.JsonOptions
		).ConfigureAwait(false))!;
#endif

		entries = response.Data.MediaListCollection.Lists
			.SelectMany(l => l.Entries.Select(e => e.Media))
			.Where(x => x?.Status == MediaStatus.FINISHED)
			.OrderBy(x => x.Id)
			.ToList();

		search = new(entries);
		// By default, sorted ascending by id
		// keySelector here won't be the same instance as the passed in argument
		// so no point in giving it any value other than null
		lastSortedBy = new(null, IsAscending: true);
	}

	private void GenreSelected(ChangeEventArgs e)
	{
		search.Genres.Add(e.Value?.ToString()!);
		search.UpdateVisibility(entries);
	}

	private void TagSelected(ChangeEventArgs e)
	{
		search.Tags.Add(e.Value?.ToString()!);
		search.UpdateVisibility(entries);
	}

	private void SortEntries<TKey>(Func<Media, TKey> keySelector)
	{
		var nullsAtEnd = entries!.OrderBy(x => keySelector(x) == null);
		if (!lastSortedBy.IsAscending
			|| !object.ReferenceEquals(lastSortedBy.KeySelector, keySelector))
		{
			entries = nullsAtEnd.ThenBy(keySelector).ToList();
			lastSortedBy = new(keySelector, IsAscending: true);
		}
		else
		{
			entries = nullsAtEnd.ThenByDescending(keySelector).ToList();
			lastSortedBy = new(keySelector, IsAscending: false);
		}
	}

	private record struct LastSortedBy(object? KeySelector, bool IsAscending);

	private sealed class Search
	{
		public ImmutableArray<string> AvailableGenres { get; private set; }
		public ImmutableArray<string> AvailableTags { get; private set; }
		public bool IsModalActive { get; private set; }
		public HashSet<string> Genres { get; set; } = new();
		public HashSet<string> Tags { get; set; } = new();

		public Search() : this(Enumerable.Empty<Media>())
		{
		}

		public Search(IEnumerable<Media> entries)
		{
			UpdateAvailableSearchOptions(entries);
		}

		public bool GetUpdatedVisibility(Media media)
		{
			foreach (var genre in Genres)
			{
				if (!media.Genres.Contains(genre))
				{
					return false;
				}
			}
			foreach (var tag in Tags)
			{
				if (!media.Tags.Any(x => x.Name == tag))
				{
					return false;
				}
			}
			return true;
		}

		public void ToggleModal()
			=> IsModalActive = !IsModalActive;

		public void UpdateAvailableSearchOptions(IEnumerable<Media> entries)
		{
			var availableGenres = new HashSet<string>();
			var availableTags = new HashSet<string>();
			foreach (var entry in entries)
			{
				if (!entry.IsEntryVisible)
				{
					continue;
				}

				foreach (var genre in entry.Genres)
				{
					availableGenres.Add(genre);
				}
				foreach (var tag in entry.Tags)
				{
					availableTags.Add(tag.Name);
				}
			}
			AvailableGenres = availableGenres.OrderBy(x => x).ToImmutableArray();
			AvailableTags = availableTags.OrderBy(x => x).ToImmutableArray();
		}

		public void UpdateVisibility(IEnumerable<Media> media)
		{
			foreach (var item in media)
			{
				item.IsEntryVisible = GetUpdatedVisibility(item);
			}
		}
	}
}